<#@ assembly name="System.Core" #>
<#@ assembly name="System.Runtime" #>
<#@ assembly name="$(ProjectDir)..\packages\Microsoft.Bcl.Immutable.1.0.8-beta\lib\net45\System.Collections.Immutable.dll" #>
<#@ assembly name="$(ProjectDir)bin\debug\ImmutableObjectGraph.dll" #>
<#@ Import Namespace="ImmutableObjectGraph" #>
<#@ Import Namespace="System.Collections.Generic" #>
<#@ Import Namespace="System.Collections.Immutable" #>
<#@ Import Namespace="System.Diagnostics" #>
<#@ import namespace="System.Linq" #>
<#@ Import Namespace="System.Reflection" #>
<#@ import namespace="System.Text" #>
<#@ Include File="..\ImmutableObjectGraph\ImmutableObjectGraph.Discovery.tt" #>
<#@ Include File="..\ImmutableObjectGraph\ImmutableObjectGraph.Interface.tt" #>
<#@ Include File="..\ImmutableObjectGraph\ImmutableObjectGraph.WithProperty.tt" #>
<#@ Include File="..\ImmutableObjectGraph\ImmutableObjectGraph.CollectionHelpers.tt" #>
<#@ Include File="..\ImmutableObjectGraph\ImmutableObjectGraph.DeepMutation.tt" #>
<#@ Include File="..\ImmutableObjectGraph\ImmutableObjectGraph.TypeConversion.tt" #>
<#@ Include File="..\ImmutableObjectGraph\ImmutableObjectGraph.Builders.tt" #>
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ImmutableTree Version: 0.0.0.1
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

namespace <#= this.Namespace #> {
	using System.Diagnostics;
	using System.Linq;
	using ImmutableObjectGraph;
<#
	this.PushIndent("\t");
	foreach(var templateType in TemplateTypes) {
		this.OnHandleType(templateType, HandleTypePosition.BeforeTypeDeclaration);
#>

public <#= templateType.IsAbstract ? "abstract " : "" #>partial class <#= templateType.TypeName #> : <#= templateType.HasAncestor ? (templateType.Ancestor.TypeName + ", ") : "" #>I<#= templateType.TypeName #><# if (templateType.IsRecursive) { #>, System.Collections.Generic.IEnumerable<<#=templateType.RecursiveType.TypeName#>><# } #> {
<#	if (!templateType.IsAbstract) { #>
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static readonly <#= templateType.TypeName #> DefaultInstance = GetDefaultTemplate();
<#	}
	foreach(var field in templateType.LocalFields) {
#>

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private readonly <#= field.TypeName #> <#= field.NameCamelCase #>;
<#
	}
#>

	/// <summary>Initializes a new instance of the <#= templateType.TypeName #> class.</summary>
	protected <#= templateType.TypeName #>()
	{
	}

<#
	bool firstInSequence = true;
	if (templateType.LocalFields.Count > 0) { #>
	/// <summary>Initializes a new instance of the <#= templateType.TypeName #> class.</summary>
	protected <#= templateType.TypeName #>(<# WriteParameters(templateType.AllFields, ParameterStyle.Required); #>)
		: base(<# WriteArguments(templateType.AllFields.Where(f => f.DeclaringType != templateType), ArgSource.Argument); #>)
	{
<#
	foreach(var field in templateType.LocalFields) {
#>
		this.<#= field.NameCamelCase #> = <#= field.NameCamelCase #>;
<#
	}

	if (!templateType.IsAbstract) {
#>
		this.Validate();
<#	} #>
	}
<# }

	if (!templateType.IsAbstract) { #>

	public static <#= templateType.TypeName #> Create(<# WriteParameters(templateType.AllFields, ParameterStyle.OptionalOrRequired); #>) {
		return DefaultInstance<# if (templateType.LocalFields.Count > 0) { #>.With(<#
		WriteArguments(templateType.AllFields, ArgSource.OptionalArgumentOrTemplate);
#>)<# } /* if (templateType.LocalFields.Count > 0) */ #>;
	}
<#
	} // !IsAbstract Create factory method

	foreach(var field in templateType.LocalFields) {
#>

	public <#= field.TypeName #> <#= field.NamePascalCase #> {
		get { return this.<#= field.NameCamelCase #>; }
	}
<#  } // foreach Fields

	foreach(var field in templateType.AllFields) {
		this.OnHandleField(templateType, field);
	}

	if (templateType.LocalFields.Count > 0) {
		if (templateType.HasAncestor) {
#>

	/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
	public override <#= templateType.Ancestor.TypeName #> With(<# WriteParameters(templateType.Ancestor.AllFields, ParameterStyle.Optional); #>) {
		return this.With(<#
			WriteArguments(templateType.Ancestor.AllFields, ArgSource.Argument);
			Write(",");
			WriteArguments(templateType.LocalFields, ArgSource.Missing);
#>);
	}
	<# } /* templateType.HasAncestor */ #>

	/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
	public <#= templateType.IsAbstract ? "abstract" : "virtual" #> <#= templateType.TypeName #> With(<#
		WriteParameters(templateType.AllFields, ParameterStyle.Optional);
#>)<# if (templateType.IsAbstract) { #>;<# } else { #> {
		if (<#
			firstInSequence = true;
			foreach(var field in templateType.AllFields) {
				if (!firstInSequence) { Write(" || "); }
				WriteLine("");
#>			(<#= field.NameCamelCase #>.IsDefined && <#= field.NameCamelCase #>.Value != this.<#= field.NamePascalCase #>)<#
				firstInSequence = false;
			}
	#>) {
			return new <#= templateType.TypeName #>(<# WriteArguments(templateType.AllFields, ArgSource.OptionalArgumentOrProperty, indent: 4); #>);
		} else {
			return this;
		}
	}
<#		} /* if isAbstract */ #>
<#	} /* templateType.LocalFields.Count > 0 */ #>

<# if (templateType.IsRecursive) { #>

	public System.Collections.Generic.IEnumerator<<#=templateType.RecursiveType.TypeName#>> GetEnumerator() {
		return this.<#=templateType.RecursiveField.NameCamelCase#>.GetEnumerator();
	}

	System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() {
		return this.<#=templateType.RecursiveField.NameCamelCase#>.GetEnumerator();
	}
<# }
	if (!templateType.IsAbstract) { #>
	/// <summary>Normalizes and/or validates all properties on this object.</summary>
	/// <exception type="ArgumentException">Thrown if any properties have disallowed values.</exception>
	partial void Validate();

	/// <summary>Provides defaults for fields.</summary>
	/// <param name="template">The struct to set default values on.</param>
	static partial void CreateDefaultTemplate(ref Template template);

	/// <summary>Returns a newly instantiated <#= templateType.TypeName #> whose fields are initialized with default values.</summary>
	private static <#= templateType.TypeName #> GetDefaultTemplate() {
		var template = new Template();
		CreateDefaultTemplate(ref template);
		return new <#= templateType.TypeName #>(<#
		firstInSequence = true;
		this.PushIndent("\t\t\t");

		// Value parameters
		foreach(var field in templateType.AllFields) {
			if (!firstInSequence) { Write(", "); }
			WriteLine("");
			Write("template.");
			Write(field.NamePascalCase);
			firstInSequence = false;
		}

		this.PopIndent();
#>);
	}
<# } /* !IsAbstract */
if (!templateType.IsAbstract) { #>

	/// <summary>A struct with all the same fields as the containing type for use in describing default values for new instances of the class.</summary>
	private struct Template {<#
	foreach(var field in templateType.AllFields) {
#>

		internal <#= field.TypeName #> <#= field.NamePascalCase #> { get; set; }
<#
	}
#>
	}
<#	} /* !IsAbstract */

	this.OnHandleType(templateType, HandleTypePosition.WithinTypeDeclaration, indent: 1);
#>
}
<#
		this.OnHandleType(templateType, HandleTypePosition.AfterTypeDeclaration);
	} // looping over all template types

	this.PopIndent();
#>
}

<#+
	public string Namespace { get; set; }

	protected enum HandleTypePosition {
		BeforeTypeDeclaration,

		WithinTypeDeclaration,

		AfterTypeDeclaration,
	}

	protected event Action<MetaType, HandleTypePosition> HandleType;

	protected event Action<MetaType, HandleTypePosition> HandleRedType;

	protected event Action<MetaType, MetaType.MetaField> HandleField;

	protected event Action<MetaType, MetaType.MetaField> HandleRedField;

	protected void OnHandleType(MetaType type, HandleTypePosition position, int indent = 0) {
		var handleType = this.HandleType;
		if (handleType != null) {
			this.PushIndent(new string('\t', indent));
			handleType(type, position);
			this.PopIndent();
		}
	}

	protected void OnHandleRedType(MetaType type, HandleTypePosition position, int indent = 0) {
		var handleRedType = this.HandleRedType;
		if (handleRedType != null) {
			this.PushIndent(new string('\t', indent));
			handleRedType(type, position);
			this.PopIndent();
		}
	}

	protected void OnHandleField(MetaType type, MetaType.MetaField field) {
		var handleField = this.HandleField;
		if (handleField != null) {
			this.PushIndent("\t");
			handleField(type, field);
			this.PopIndent();
		}
	}

	protected void OnHandleRedField(MetaType type, MetaType.MetaField field) {
		var handleRedField = this.HandleRedField;
		if (handleRedField != null) {
			this.PushIndent("\t");
			handleRedField(type, field);
			this.PopIndent();
		}
	}

	protected void WriteBaseTypes(params string[] typeNames) {
		var elements = typeNames.Where(t => t != null);
		if (elements.Any()) {
			Write(" : ");
			bool firstElement = true;
			foreach (var element in elements) {
				if (!firstElement) {
					Write(", ");
				}

				Write(element);
				firstElement = false;
			}
		}
	}
#>
