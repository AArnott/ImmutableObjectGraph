// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ImmutableTree Version: 0.0.0.1
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

namespace ImmutableObjectGraph {
	using System.Diagnostics;

	/// <summary>
	/// A wrapper around optional parameters to capture whether they were specified or omitted.
	/// An implicit operator is defined so no one has to explicitly create this struct.
	/// </summary>
	public struct Optional<T> {
		private readonly T value;
		private readonly bool isDefined;

		public Optional(T value) {
			this.isDefined = true;
			this.value = value;
		}

		public bool IsDefined {
			get { return this.isDefined; }
		}

		public T Value {
			get { return this.value; }
		}

		public static implicit operator Optional<T>(T value) {
			return new Optional<T>(value);
		}
	}

	public static class Optional {
		public static Optional<T> For<T>(T value) {
			return value;
		}
	}

	
	public partial class Basket {
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private static readonly Basket DefaultInstance = new Basket();
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly System.Int32 size;
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly System.Collections.Immutable.IImmutableList<Fruit> contents;
	
		/// <summary>Initializes a new instance of the Basket class.</summary>
		private Basket()
		{
		}
	
		/// <summary>Initializes a new instance of the Basket class.</summary>
		private Basket(System.Int32 size, System.Collections.Immutable.IImmutableList<Fruit> contents)
		{
			this.size = size;
			this.contents = contents;
			this.Validate();
		}
	
		public static Basket Default {
			get { return DefaultInstance; }
		}
	
		public System.Int32 Size {
			get { return this.size; }
		}
	
		public Basket WithSize(System.Int32 value) {
			if (value == this.Size) {
				return this;
			}
	
			return new Basket(value, this.Contents);
		}
	
		public System.Collections.Immutable.IImmutableList<Fruit> Contents {
			get { return this.contents; }
		}
	
		public Basket WithContents(System.Collections.Immutable.IImmutableList<Fruit> value) {
			if (value == this.Contents) {
				return this;
			}
	
			return new Basket(this.Size, value);
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		public Basket With(
			Optional<System.Int32> size = default(Optional<System.Int32>), 
			Optional<System.Collections.Immutable.IImmutableList<Fruit>> contents = default(Optional<System.Collections.Immutable.IImmutableList<Fruit>>)) {
			return new Basket(
					size.IsDefined ? size.Value : this.Size,
					contents.IsDefined ? contents.Value : this.Contents);
		}
	
		public Builder ToBuilder() {
			return new Builder(this);
		}
	
		/// <summary>Normalizes and/or validates all properties on this object.</summary>
		/// <exception type="ArgumentException">Thrown if any properties have disallowed values.</exception>
		partial void Validate();
	
		public partial class Builder {
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			private Basket immutable;
	
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			private System.Int32 size;
	
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			private System.Collections.Immutable.IImmutableList<Fruit> contents;
	
			internal Builder(Basket immutable) {
				this.immutable = immutable;
	
				this.size = immutable.Size;
				this.contents = immutable.Contents;
			}
	
			public System.Int32 Size {
				get {
					return this.size;
				}
	
				set {
					if (this.size != value) {
						this.size = value;
						this.immutable = null;
					}
				}
			}
	
			public System.Collections.Immutable.IImmutableList<Fruit> Contents {
				get {
					return this.contents;
				}
	
				set {
					if (this.contents != value) {
						this.contents = value;
						this.immutable = null;
					}
				}
			}
	
			public Basket ToImmutable() {
				if (this.immutable == null) {
					this.immutable = Basket.Default.With(
						Optional.For(this.size),
						Optional.For(this.contents));
				}
	
				return this.immutable;
			}
		}
	}
	
	public partial class Fruit {
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private static readonly Fruit DefaultInstance = new Fruit();
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly System.String color;
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly System.Int32 skinThickness;
	
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private readonly System.ICloneable growsOn;
	
		/// <summary>Initializes a new instance of the Fruit class.</summary>
		private Fruit()
		{
		}
	
		/// <summary>Initializes a new instance of the Fruit class.</summary>
		private Fruit(System.String color, System.Int32 skinThickness, System.ICloneable growsOn)
		{
			this.color = color;
			this.skinThickness = skinThickness;
			this.growsOn = growsOn;
			this.Validate();
		}
	
		public static Fruit Default {
			get { return DefaultInstance; }
		}
	
		public System.String Color {
			get { return this.color; }
		}
	
		public Fruit WithColor(System.String value) {
			if (value == this.Color) {
				return this;
			}
	
			return new Fruit(value, this.SkinThickness, this.GrowsOn);
		}
	
		public System.Int32 SkinThickness {
			get { return this.skinThickness; }
		}
	
		public Fruit WithSkinThickness(System.Int32 value) {
			if (value == this.SkinThickness) {
				return this;
			}
	
			return new Fruit(this.Color, value, this.GrowsOn);
		}
	
		public System.ICloneable GrowsOn {
			get { return this.growsOn; }
		}
	
		public Fruit WithGrowsOn(System.ICloneable value) {
			if (value == this.GrowsOn) {
				return this;
			}
	
			return new Fruit(this.Color, this.SkinThickness, value);
		}
	
		/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
		public Fruit With(
			Optional<System.String> color = default(Optional<System.String>), 
			Optional<System.Int32> skinThickness = default(Optional<System.Int32>), 
			Optional<System.ICloneable> growsOn = default(Optional<System.ICloneable>)) {
			return new Fruit(
					color.IsDefined ? color.Value : this.Color,
					skinThickness.IsDefined ? skinThickness.Value : this.SkinThickness,
					growsOn.IsDefined ? growsOn.Value : this.GrowsOn);
		}
	
		public Builder ToBuilder() {
			return new Builder(this);
		}
	
		/// <summary>Normalizes and/or validates all properties on this object.</summary>
		/// <exception type="ArgumentException">Thrown if any properties have disallowed values.</exception>
		partial void Validate();
	
		public partial class Builder {
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			private Fruit immutable;
	
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			private System.String color;
	
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			private System.Int32 skinThickness;
	
			[DebuggerBrowsable(DebuggerBrowsableState.Never)]
			private System.ICloneable growsOn;
	
			internal Builder(Fruit immutable) {
				this.immutable = immutable;
	
				this.color = immutable.Color;
				this.skinThickness = immutable.SkinThickness;
				this.growsOn = immutable.GrowsOn;
			}
	
			public System.String Color {
				get {
					return this.color;
				}
	
				set {
					if (this.color != value) {
						this.color = value;
						this.immutable = null;
					}
				}
			}
	
			public System.Int32 SkinThickness {
				get {
					return this.skinThickness;
				}
	
				set {
					if (this.skinThickness != value) {
						this.skinThickness = value;
						this.immutable = null;
					}
				}
			}
	
			public System.ICloneable GrowsOn {
				get {
					return this.growsOn;
				}
	
				set {
					if (this.growsOn != value) {
						this.growsOn = value;
						this.immutable = null;
					}
				}
			}
	
			public Fruit ToImmutable() {
				if (this.immutable == null) {
					this.immutable = Fruit.Default.With(
						Optional.For(this.color),
						Optional.For(this.skinThickness),
						Optional.For(this.growsOn));
				}
	
				return this.immutable;
			}
		}
	}
}

