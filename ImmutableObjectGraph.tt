<#@ assembly name="System.Core" #>
<#@ Import Namespace="System.Reflection" #>
<#@ Import Namespace="System.Collections.Generic" #>
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ImmutableTree Version: 0.0.0.1
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

namespace <#= this.Namespace #> {
	using System.Diagnostics;

<#
	this.PushIndent("\t");
	var templateTypes = DiscoverTemplateTypes(this.TemplateType);
	foreach(var templateType in templateTypes) {
#>

public partial class <#= templateType.Name #> {
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static readonly <#= templateType.Name #> DefaultInstance = new <#= templateType.Name #>();
<#
	var fields = templateType.GetFields(BindingFlags.NonPublic | BindingFlags.Instance);
	foreach(var field in fields) {
#>

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private readonly <#= GetTypeName(field.FieldType) #> <#= CamelCase(field.Name) #>;
<#
	}
#>

	/// <summary>Initializes a new instance of the <#= templateType.Name #> class.</summary>
	private <#= templateType.Name #>()
	{
	}

	/// <summary>Initializes a new instance of the <#= templateType.Name #> class.</summary>
	private <#= templateType.Name #>(<#
	bool firstInSequence = true;
	foreach(var field in fields) {
		if (!firstInSequence) { Write(", "); }
		Write(GetTypeName(field.FieldType));
		Write(" ");
		Write(CamelCase(field.Name));
		firstInSequence = false;
	}
#>)
	{
<#
	foreach(var field in fields) {
#>
		this.<#= CamelCase(field.Name) #> = <#= CamelCase(field.Name) #>;
<#
	}
#>
		this.Validate();
	}

	public static <#= templateType.Name #> Default {
		get { return DefaultInstance; }
	}
<#
	foreach(var field in fields) {
#>

	public <#= GetTypeName(field.FieldType) #> <#= PascalCase(field.Name) #> {
		get { return this.<#= CamelCase(field.Name) #>; }
	}

	public <#=  templateType.Name #> With<#= PascalCase(field.Name) #>(<#= GetTypeName(field.FieldType) #> value) {
		if (value == this.<#= PascalCase(field.Name) #>) {
			return this;
		}

		return new <#= templateType.Name #>(<#
	firstInSequence = true;
	foreach(var field2 in fields) {
		if (!firstInSequence) { Write(", "); }
		if (field == field2) {
			Write("value");
		} else {
			Write("this." + PascalCase(field2.Name));
		}

		firstInSequence = false;
	}
#>);
	}
<#
	}
#>

	/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
	public <#= templateType.Name #> With(<#
		firstInSequence = true;
		this.PushIndent("\t\t");

		// Value parameters
		foreach(var field in fields) {
			if (!firstInSequence) { Write(", "); }
			WriteLine("");
			Write(GetTypeName(field.FieldType));
			Write(" ");
			Write(CamelCase(field.Name));
			Write(" = default(" + GetTypeName(field.FieldType) + ")");
			firstInSequence = false;
		}

		// Reset parameters
		foreach(var field in fields) {
			WriteLine(",");
			Write("bool ");
			Write("reset" + PascalCase(field.Name));
			Write(" = false");
			firstInSequence = false;
		}

		this.PopIndent();
#>) {
		return new <#= templateType.Name #>(<#
			firstInSequence = true;
			foreach(var field in fields) {
				if (!firstInSequence) { Write(","); }
				WriteLine("");
#>				reset<#= PascalCase(field.Name) #> ? default(<#= GetTypeName(field.FieldType) #>) : (<#= CamelCase(field.Name) #> != default(<#= GetTypeName(field.FieldType) #>) ? <#= CamelCase(field.Name) #> : this.<#= PascalCase(field.Name) #>)<#
				firstInSequence = false;
			}
	#>);
	}

	public Builder ToBuilder() {
		return new Builder {
<#
			foreach(var field in fields) {
#>
			<#= PascalCase(field.Name) #> = this.<#= PascalCase(field.Name) #>,
<#			} #>
		};
	}

	/// <summary>Normalizes and/or validates all properties on this object.</summary>
	/// <exception type="ArgumentException">Thrown if any properties have disallowed values.</exception>
	partial void Validate();

	public partial class Builder {
		internal Builder() {
		}

<#		foreach(var field in fields) { #>
		public <#= GetTypeName(field.FieldType) #> <#= PascalCase(field.Name) #> { get; set; }
<#		} #>

		public <#= templateType.Name #> ToImmutable() {
			return <#= templateType.Name #>.Default.With(<#
			firstInSequence = true;
			foreach(var field in fields) {
				if (!firstInSequence) { Write(","); }
				WriteLine(""); #>
				this.<#= PascalCase(field.Name) #><#
				firstInSequence = false;
			} #>
);
		}
	}
}
<# } // looping over all template types

	this.PopIndent();
#>
}
<#+
	public Type TemplateType { get; set; }

	public string Namespace { get; set; }

	protected static string PascalCase(string name) {
		return name.Substring(0,1).ToUpperInvariant() + name.Substring(1);
	}

	protected static string CamelCase(string name) {
		return name.Substring(0,1).ToLowerInvariant() + name.Substring(1);
	}

	protected static HashSet<Type> DiscoverTemplateTypes(Type rootType) {
		var types = new HashSet<Type>();
		var pendingTypes = new Queue<Type>();
		pendingTypes.Enqueue(rootType);
		while(pendingTypes.Count > 0)
		{
			var type = pendingTypes.Dequeue();
			if (types.Add(type)) {
				foreach(var field in type.GetFields(BindingFlags.Instance | BindingFlags.NonPublic)) {
					var memberType = field.FieldType;
					if (memberType.IsArray) {
						memberType = memberType.GetElementType();
					}

					if (memberType.DeclaringType == type.DeclaringType) {
						pendingTypes.Enqueue(memberType);
					}
				}
			}
		}

		return types;
	}

	protected string GetTypeName(Type type) {
		bool collection = false;
		if (type.IsArray) {
			type = type.GetElementType();
			collection = true;
		}

		string typeName = 
			type.DeclaringType == this.TemplateType.DeclaringType
			? type.Name
			: type.FullName;

		if (collection) {
			typeName = "System.Collections.Immutable.ImmutableList<" + typeName + ">";
		}

		return typeName;
	}
#>
