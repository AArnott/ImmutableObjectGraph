<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ Import Namespace="System.Reflection" #>
<#@ Import Namespace="System.Collections.Generic" #>
// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ImmutableTree Version: 0.0.0.1
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

namespace <#= this.Namespace #> {
	using System.Diagnostics;

	/// <summary>
	/// A wrapper around optional parameters to capture whether they were specified or omitted.
	/// An implicit operator is defined so no one has to explicitly create this struct.
	/// </summary>
	public struct Optional<T> {
		private readonly T value;
		private readonly bool isDefined;

		public Optional(T value) {
			this.isDefined = true;
			this.value = value;
		}

		public bool IsDefined {
			get { return this.isDefined; }
		}

		public T Value {
			get { return this.value; }
		}

		public static implicit operator Optional<T>(T value) {
			return new Optional<T>(value);
		}
	}

	public static class Optional {
		public static Optional<T> For<T>(T value) {
			return value;
		}
	}

<#
	this.PushIndent("\t");
	var templateTypes = DiscoverTemplateTypes(this.TemplateType);
	foreach(var templateType in templateTypes) {
#>

public partial class <#= templateType.Name #> {
	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private static readonly <#= templateType.Name #> DefaultInstance = new <#= templateType.Name #>();
<#
	var fields = templateType.GetFields(BindingFlags.NonPublic | BindingFlags.Instance);
	foreach(var field in fields) {
#>

	[DebuggerBrowsable(DebuggerBrowsableState.Never)]
	private readonly <#= GetTypeName(field.FieldType) #> <#= CamelCase(field.Name) #>;
<#
	}
#>

	/// <summary>Initializes a new instance of the <#= templateType.Name #> class.</summary>
	private <#= templateType.Name #>()
	{
	}

	/// <summary>Initializes a new instance of the <#= templateType.Name #> class.</summary>
	private <#= templateType.Name #>(<#
	bool firstInSequence = true;
	foreach(var field in fields) {
		if (!firstInSequence) { Write(", "); }
		Write(GetTypeName(field.FieldType));
		Write(" ");
		Write(CamelCase(field.Name));
		firstInSequence = false;
	}
#>)
	{
<#
	foreach(var field in fields) {
#>
		this.<#= CamelCase(field.Name) #> = <#= CamelCase(field.Name) #>;
<#
	}
#>
		this.Validate();
	}

	public static <#= templateType.Name #> Default {
		get { return DefaultInstance; }
	}
<#
	foreach(var field in fields) {
#>

	public <#= GetTypeName(field.FieldType) #> <#= PascalCase(field.Name) #> {
		get { return this.<#= CamelCase(field.Name) #>; }
	}

	public <#= templateType.Name #> With<#= PascalCase(field.Name) #>(<#= GetTypeName(field.FieldType) #> value) {
		if (value == this.<#= PascalCase(field.Name) #>) {
			return this;
		}

		return new <#= templateType.Name #>(<#
	firstInSequence = true;
	foreach(var field2 in fields) {
		if (!firstInSequence) { Write(", "); }
		if (field == field2) {
			Write("value");
		} else {
			Write("this." + PascalCase(field2.Name));
		}

		firstInSequence = false;
	}
#>);
	}
<#
	}
#>

	/// <summary>Returns a new instance of this object with any number of properties changed.</summary>
	public <#= templateType.Name #> With(<#
		firstInSequence = true;
		this.PushIndent("\t\t");

		// Value parameters
		foreach(var field in fields) {
			if (!firstInSequence) { Write(", "); }
			WriteLine("");
			Write(GetOptionalTypeName(field.FieldType));
			Write(CamelCase(field.Name));
			Write(" = default(" + GetOptionalTypeName(field.FieldType) + ")");
			firstInSequence = false;
		}

		this.PopIndent();
#>) {
		return new <#= templateType.Name #>(<#
			firstInSequence = true;
			foreach(var field in fields) {
				if (!firstInSequence) { Write(","); }
				WriteLine("");
#>				<#= CamelCase(field.Name) #>.IsDefined ? <#= CamelCase(field.Name) #>.Value : this.<#= PascalCase(field.Name) #><#
				firstInSequence = false;
			}
	#>);
	}

	public Builder ToBuilder() {
		return new Builder(this);
	}

	/// <summary>Normalizes and/or validates all properties on this object.</summary>
	/// <exception type="ArgumentException">Thrown if any properties have disallowed values.</exception>
	partial void Validate();

	public partial class Builder {
		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private <#= templateType.Name #> immutable;
<#		foreach(var field in fields) { #>

		[DebuggerBrowsable(DebuggerBrowsableState.Never)]
		private <#= GetTypeName(field.FieldType) #> <#= CamelCase(field.Name) #>;
<#		} #>

		internal Builder(<#= templateType.Name #> immutable) {
			this.immutable = immutable;

<#
			foreach(var field in fields) {
#>
			this.<#= CamelCase(field.Name) #> = immutable.<#= PascalCase(field.Name) #>;
<#			} #>
		}
<#		foreach(var field in fields) { #>

		public <#= GetTypeName(field.FieldType) #> <#= PascalCase(field.Name) #> {
			get {
				return this.<#= CamelCase(field.Name) #>;
			}

			set {
				if (this.<#= CamelCase(field.Name) #> != value) {
					this.<#= CamelCase(field.Name) #> = value;
					this.immutable = null;
				}
			}
		}
<#		} #>

		public <#= templateType.Name #> ToImmutable() {
			if (this.immutable == null) {
				this.immutable = <#= templateType.Name #>.Default.With(<#
			firstInSequence = true;
			foreach(var field in fields) {
				if (!firstInSequence) { Write(","); }
				WriteLine(""); #>
					Optional.For(this.<#= CamelCase(field.Name) #>)<#
				firstInSequence = false;
			} #>
);
			}

			return this.immutable;
		}
	}
}
<# } // looping over all template types

	this.PopIndent();
#>
}
<#+
	public Type TemplateType { get; set; }

	public string Namespace { get; set; }

	public bool UseClassCollectionType { get; set; }

	protected static string PascalCase(string name) {
		return name.Substring(0,1).ToUpperInvariant() + name.Substring(1);
	}

	protected static string CamelCase(string name) {
		return name.Substring(0,1).ToLowerInvariant() + name.Substring(1);
	}

	protected static HashSet<Type> DiscoverTemplateTypes(Type rootType) {
		var types = new HashSet<Type>();
		var pendingTypes = new Queue<Type>();
		pendingTypes.Enqueue(rootType);
		while(pendingTypes.Count > 0)
		{
			var type = pendingTypes.Dequeue();
			if (types.Add(type)) {
				foreach(var field in type.GetFields(BindingFlags.Instance | BindingFlags.NonPublic)) {
					var memberType = field.FieldType;
					if (memberType.IsArray) {
						memberType = memberType.GetElementType();
					}

					if (memberType.DeclaringType == type.DeclaringType) {
						pendingTypes.Enqueue(memberType);
					}
				}
			}
		}

		return types;
	}

	protected string GetTypeName(Type type) {
		bool collection = false;
		if (type.IsArray) {
			type = type.GetElementType();
			collection = true;
		}

		string typeName = 
			type.DeclaringType == this.TemplateType.DeclaringType
			? type.Name
			: type.FullName;

		if (collection) {
			if (UseClassCollectionType)
				typeName = "System.Collections.Immutable.ImmutableList<" + typeName + ">";
			else
				typeName = "System.Collections.Immutable.IImmutableList<" + typeName + ">";
		}

		return typeName;
	}

	protected string GetOptionalTypeName(Type type)
	{
		return "Optional<" + GetTypeName(type) + ">";
	}

#>
